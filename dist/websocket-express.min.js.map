{"version":3,"sources":["websockets-express.js"],"names":["global","WebSocketServiceInstance","buffer","ready","afterReady","Set","defaultSocketId","chars","split","endpoints","Map","callbacks","acknowledgements","sendQueue","sockets","parsers","status","SOCKETSTATUS","Object","freeze","CONNECTING","RECONNECTING","CLOSED","CONNECTED","HTTP_ERROR","_Error","message","_getPrototypeOf2","_this","_classCallCheck","this","_len","arguments","length","params","Array","_key","_possibleConstructorReturn","_getPrototypeOf","call","apply","concat","_inherits","_wrapNativeSuper","Error","onReady","url","_ref","location","origin","document","querySelector","baseElement","base","getAttribute","trim","replace","set","setDefaultEndPoint","endpointLinkElements","querySelectorAll","n","title","setEndpoints","forEach","callback","clear","notEnum","enumeral","checks","_status","check","randomString","undefined","fill","map","end","start","Math","floor","random","randomInt","join","socketReady","socketId","has","ws","get","readyState","OPEN","getCallbacks","type","removeCallback","delete","connecting","open","WebSocketService","DEBUG","console","log","addEventListener","close","_sendQueue","messageFunction","send","runSendQueue","removeEventListener","setTimeout","WebSocket","messageEvent","respond","id","acknowledgement","data","JSON","parse","Blob","reader","FileReader","onload","Buffer","Uint8Array","result","readAsArrayBuffer","err","error","connect","add","URIError","setEnpointUrl","defaultJsonParser","stringify","TypeError","addParser","_createClass","key","value","method","Promise","resolve","reject","response","body","statusMessage","request","parser","Symbol","toStringTag","_global$jQuery","jQuery","$","angular","bolt","doc","completed","window","websocket","module","factory","MODE","BoltWebSocketService","documentElement","doScroll","init"],"mappings":"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","file":"websocket-express.min.js","sourcesContent":["(function(global){\n\t'use strict';\n\n\tlet buffer = global.buffer;\n\tlet ready = false;\n\n\tconst afterReady = new Set();\n\tconst defaultSocketId = 'main';\n\tconst chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('');\n\tconst endpoints = new Map();\n\tconst callbacks = new Map();\n\tconst acknowledgements = new Map();\n\tconst sendQueue = new Map();\n\tconst sockets = new Map();\n\tconst parsers = new Map();\n\tconst status = new Map();\n\tconst SOCKETSTATUS = Object.freeze({\n\t\tCONNECTING: 1,\n\t\tRECONNECTING: 2,\n\t\tCLOSED: 3,\n\t\tCONNECTED: 4\n\t});\n\n\tclass HTTP_ERROR extends Error {\n\t\tconstructor(message, ...params) {\n\t\t\tsuper(message.message,...params);\n\t\t\tthis.status = message.status;\n\t\t}\n\t}\n\n\t/**\n\t * Initiate this module, binding into all the correct global and framework points.\n\t */\n\tfunction init() {\n\t\tconst {\n\t\t\tjQuery=((!!global.$ && !!global.$.jQuery)?global.$:undefined),\n\t\t\tangular,\n\t\t\tbolt,\n\t\t\tdocument:doc\n\t\t} = global;\n\n\t\tif (!!jQuery) global.jQuery.websocket = new WebSocketService();\n\t\tif (!!angular) angular.module(\"websocket-express\", []).factory(\"$websocket\", ()=>new WebSocketService());\n\t\tif (!!bolt) {\n\t\t\tbolt.WebSocketService = WebSocketService;\n\t\t\tif (!!bolt.MODE && (bolt.MODE.has(\"DEVELOPMENT\") || bolt.MODE.has(\"DEBUG\"))) {\n\t\t\t\tbolt.WebSocketService.DEBUG = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!!bolt && !!jQuery && !!angular) global.BoltWebSocketService = WebSocketService;\n\n\t\t// This is extracted from jQuery.ready(), we want the works in all situations provided by jQuery without\n\t\t// the jQuery dependency. (@see https://github.com/jquery/jquery/blob/master/src/core/ready.js).\n\t\tfunction completed() {\n\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", completed);\n\t\t\twindow.removeEventListener(\"load\", completed);\n\t\t\tonReady();\n\t\t}\n\n\t\tif (doc.readyState===\"complete\" || (doc.readyState !==\"loading\" && !doc.documentElement.doScroll)) {\n\t\t\twindow.setTimeout(onReady);\n\t\t} else {\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\t\t\twindow.addEventListener( \"load\", completed );\n\t\t}\n\t}\n\n\t/**\n\t * Function to call when document is ready.  Only run once to perform all waiting websocket messages.\n\t */\n\tfunction onReady() {\n\t\tsetEndpoints();\n\t\tready = true;\n\t\tafterReady.forEach(callback=>callback());\n\t\tafterReady.clear();\n\t}\n\n\t/**\n\t * Check if a status property is not one of a number of enum values.\n\t *\n\t * @param {*} status\t\t\tStatus to check.\n\t * @param {Object} enumeral\t\tEnum to check within.\n\t * @param {Arrray} checks\t\tEnum values to check.\n\t * @returns {boolean}\t\t\tDoes it pass the test.\n\t */\n\tfunction notEnum(status, enumeral, checks) {\n\t\tlet _status = true;\n\t\tchecks.forEach(check=>{\n\t\t\t_status = _status && (status !== enumeral[check])\n\t\t});\n\t\treturn _status;\n\t}\n\n\t/**\n\t * Generate a random integer between a start end end value.\n\t *\n\t * @param {integer} end\t\t\t\tThe start of the range.\n\t * @param {integer} [start=0]\t\tThe end of the range.\n\t * @returns {integer}\t\t\t\tRandom generated number.\n\t */\n\tfunction randomInt(end, start=0) {\n\t\treturn Math.floor(Math.random() * end) + start;\n\t}\n\n\t/**\n\t * Generate a randomstring.\n\t *\n\t * @param {integer} [length=32]\t\tThe length of string to generate.\n\t * @returns {string}\t\t\t\tRandom generated string.\n\t */\n\tfunction randomString(length=32) {\n\t\treturn (new Array(length)).fill(0).map(()=>chars[randomInt(chars.length - 1)]).join('');\n\t}\n\n\t/**\n\t * Search through all the locations for websocket endpoint definitions setting these.  Will use defaults if non\n\t * found. These can be defined in <link rel=\"websocket-endpoint\"> tags, where the title attribute is the endpoint\n\t * name and the href is the endpoint.\n\t */\n\tfunction setEndpoints() {\n\t\tsetDefaultEndPoint();\n\n\t\tlet endpointLinkElements = global.document.querySelectorAll(\"link[rel=websocket-endpoint][href]\");\n\t\tif (endpointLinkElements.length) {\n\t\t\tfor (let n=0; n < endpointLinkElements.length; n++) {\n\t\t\t\tlet url = (endpointLinkElements[n].getAttribute(\"href\") || \"\").trim();\n\t\t\t\tif (url !== \"\") {\n\t\t\t\t\tlet title = (endpointLinkElements[n].getAttribute(\"title\") || \"\").trim();\n\t\t\t\t\tif (title === \"\") title = defaultSocketId;\n\t\t\t\t\tendpoints.set(title, url);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the endpoint of the default endpoint, searching all the definition points for this.\n\t */\n\tfunction setDefaultEndPoint() {\n\t\tconst [origin, baseElement] = [global.location.origin, global.document.querySelector(\"base[href]\")];\n\t\tlet url;\n\t\tif (baseElement) {\n\t\t\tconst base = (baseElement.getAttribute(\"href\") || \"\").trim().replace(origin, \"\");\n\t\t\tif (base !== \"\") url = `${origin}${base}`;\n\t\t} else {\n\t\t\turl = `${origin}/`;\n\t\t}\n\n\t\turl = url\n\t\t\t.replace(\"https://\", \"wss://\")\n\t\t\t.replace(\"http://\", \"ws://\");\n\n\t\tendpoints.set(defaultSocketId, url);\n\t}\n\n\t/**\n\t * Create an acknowledge handler.\n\t *\n\t * @param {Function} resolve\t\tPromise resolve handler.\n\t * @param {Function} reject\t\t\tPromise rejection handler.\n\t * @returns {Function}\t\t\t\tThe handler.\n\t */\n\tfunction createAcknowledge(resolve, reject) {\n\t\treturn (err, response)=>{\n\t\t\tif (err) return reject(err);\n\t\t\tif ((response.status || 200) >= 400) {\n\t\t\t\tif (err) return reject(err);\n\t\t\t\tconst message = (response.body || response.statusMessage || \"\").trim();\n\t\t\t\tconst status = (response.status || 400);\n\t\t\t\treturn reject(new HTTP_ERROR({message, status}));\n\t\t\t}\n\t\t\treturn resolve(response);\n\t\t};\n\t}\n\n\t/**\n\t * Is given websocket ready for transporting data?\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to test.\n\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t */\n\tfunction socketReady(socketId=defaultSocketId) {\n\t\tif (!sockets.has(socketId)) return undefined;\n\t\tconst ws = sockets.get(socketId);\n\t\treturn ((ws.readyState === ws.OPEN) ? ws : undefined);\n\t}\n\n\t/**\n\t * Send all the messages for a given socket that are in the queue.\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to send messages for.\n\t */\n\tfunction runSendQueue(socketId=defaultSocketId) {\n\t\tconst _sendQueue = sendQueue.get(socketId);\n\t\tconst ws = socketReady(socketId);\n\t\tif (_sendQueue && ws) {\n\t\t\t_sendQueue.forEach(messageFunction=>ws.send(messageFunction()));\n\t\t\t_sendQueue.clear();\n\t\t\tsendQueue.delete(socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Send a given message on a given socket.\n\t *\n\t * @param {Function} messageFunction\t\t\t\tMessage function to call to generate the message.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to send on.\n\t */\n\tfunction send(messageFunction, socketId=defaultSocketId) {\n\t\tconst ws = socketReady(socketId);\n\t\tif (ws) return ws.send(messageFunction());\n\t\tif (!sendQueue.has(socketId)) sendQueue.set(socketId, new Set());\n\t\tsendQueue.get(socketId).add(messageFunction);\n\t}\n\n\t/**\n\t * Get callbacksfor given listen type on given socket.\n\t * @param {string} type\t\t\t\t\t\t\t\tThe type to get for.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to get callbacks for.\n\t * @returns {Array.<Function>}\t\t\t\t\t\tArray of callbacks.\n\t */\n\tfunction getCallbacks(type, socketId=defaultSocketId) {\n\t\tif (!callbacks.has(socketId)) callbacks.set(socketId, new Map());\n\t\tif (!callbacks.get(socketId).has(type)) callbacks.get(socketId).set(type, new Set());\n\t\treturn callbacks.get(socketId).get(type);\n\t}\n\n\t/**\n\t * Remove the given callback from a callback set.\n\t *\n\t * @param {Set.<Set>} callbacks\t\tCallback to search through.\n\t * @param {Function} callback\t\tCallback to remove.\n\t */\n\tfunction removeCallback(callbacks, callback) {\n\t\tcallbacks.forEach(callbacks=>callbacks.delete(callback));\n\t}\n\n\t/**\n\t * Get the endpoint url for the given socket id.\n\t *\n\t * @param {string} [url]\t\t\tThe url to set endpoint to.\n\t * @param {string} socketId\t\t\tThe socket id to set endpoint on.\n\t * @returns {string}\t\t\t\tThe endpoint url for given socket id.\n\t */\n\tfunction setEnpointUrl(url, socketId) {\n\t\tif (url) {\n\t\t\tif (!ready) {\n\t\t\t\tafterReady.add(()=>endpoints.set(socketId, url));\n\t\t\t} else {\n\t\t\t\tendpoints.set(socketId, url);\n\t\t\t}\n\t\t}\n\t\tif (!url && !endpoints.has(socketId)) throw new URIError(`No websocket endpoint for ${socketId}`);\n\t\tif (!url && endpoints.has(socketId)) url = endpoints.get(socketId);\n\n\t\treturn url;\n\t}\n\n\t/**\n\t * Try reconnecting to given socket after it has dropped.\n\t *\n\t * @param {string} url\t\t\tThe endpoint url for websocket.\n\t * @param {string} socketId\t\tThe socket id.\n\t */\n\tfunction reconnect(url, socketId) {\n\t\tsockets.delete(socketId);\n\t\tsetTimeout(()=>{\n\t\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\t\tstatus.set(socketId, SOCKETSTATUS.RECONNECTING);\n\t\t\t\tif (!!WebSocketService.DEBUG) console.log(\"Trying reconnect\");\n\t\t\t\tsockets.set(socketId, new WebSocket(url));\n\t\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t\t}\n\t\t}, 1000*3);\n\t}\n\n\tfunction drop(socketId) {\n\t\tsockets.get(socketId).close();\n\t}\n\n\t/**\n\t * Handle websocket connection, errors and reconnection.\n\t *\n\t * @param {WebSocket} ws\t\t\tThe websocket to handle.\n\t * @param {string} url\t\t\t\tThe endpoint to connect to.\n\t * @param {string} socketId\t\t\tThe socket id to set.\n\t */\n\tfunction connecting(ws, url, socketId) {\n\t\t/**\n\t\t * After open listener, setup message handling and send the message queue.\n\t\t */\n\t\tfunction open() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTED);\n\t\t\tif (!!WebSocketService.DEBUG) console.log(`Opened ${url} for ${socketId}`);\n\t\t\tws.addEventListener(\"close\", close);\n\t\t\tws.addEventListener(\"message\", message);\n\t\t\trunSendQueue(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Close listener, try to reconnect.\n\t\t */\n\t\tfunction close() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CLOSED);\n\t\t\tif (!!WebSocketService.DEBUG) console.log(`Closed ${url} for ${socketId}`);\n\t\t\tws.removeEventListener(\"open\", open);\n\t\t\tws.removeEventListener(\"close\", message);\n\t\t\tws.removeEventListener(\"message\", message);\n\t\t\treconnect(url, socketId, ws);\n\t\t}\n\n\t\t/**\n\t\t * Handle any websocket errors.\n\t\t *\n\t\t * @param {Error} err\t\tError message to handle.\n\t\t */\n\t\tfunction error(err) {\n\t\t\tconsole.error(`Error on ${url} for ${socketId}`, err);\n\t\t\treturn close();\n\t\t}\n\n\t\t/**\n\t\t * Handle a message event\n\t\t *\n\t\t * @param {Event} messageEvent\t\tThe message event to handle.\n\t\t */\n\t\tfunction message(messageEvent) {\n\t\t\tconst respond = (message)=>{\n\t\t\t\tif (!message.id) {\n\t\t\t\t\tif (callbacks.has(message.type)) {\n\t\t\t\t\t\tcallbacks.get(type).forEach(callbacks=>callback(message.data));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (acknowledgements.has(message.id)) {\n\t\t\t\t\t\tlet acknowledgement = acknowledgements.get(message.id);\n\t\t\t\t\t\tif (message.type === 'error') {\n\t\t\t\t\t\t\tacknowledgement(message.data, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tacknowledgement(null, message.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacknowledgements.delete(message.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof messageEvent.data === 'string') {\n\t\t\t\trespond(JSON.parse(messageEvent.data));\n\t\t\t} else if (messageEvent.data instanceof Blob) {\n\t\t\t\tlet reader = new FileReader();\n\t\t\t\treader.onload = function() {\n\t\t\t\t\trespond(new buffer.Buffer(new Uint8Array(this.result)));\n\t\t\t\t};\n\t\t\t\treader.readAsArrayBuffer(messageEvent.data);\n\t\t\t}\n\t\t}\n\n\t\tws.addEventListener(\"error\", error);\n\t\tws.addEventListener(\"open\", open);\n\t}\n\n\t/**\n\t * Connect to a given endpoint for socket id supplied.\n\t *\n\t * @param {string} [url]\tThe endpoint to connect to.\n\t * @param socketId\t\t\tThe socket id to connecct for.\n\t */\n\tfunction connect(url, socketId) {\n\t\turl = setEnpointUrl(url, socketId);\n\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTING);\n\t\t\tif (!sockets.has(socketId)) sockets.set(socketId, new WebSocket(url));\n\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Json parser (default one applied by default to all new socket channels).\n\t *\n\t * @param {*} data\t\tData to parse into JSON.\n\t * @returns {string}\tJSON from the data.\n\t */\n\tfunction defaultJsonParser(data) {\n\t\ttry {\n\t\t\treturn JSON.stringify(data);\n\t\t} catch(err) {\n\t\t\tthrow new TypeError(`Could not convert data to json for sending`);\n\t\t}\n\t}\n\n\tlet WebSocketServiceInstance;\n\n\t/**\n\t * Websocket handler service\n\t *\n\t * @singleton\n\t */\n\tclass WebSocketService {\n\t\tconstructor() {\n\t\t\t// Singleton pattern\n\t\t\tif (!WebSocketServiceInstance) WebSocketServiceInstance = this;\n\t\t\tthis.addParser(\"json\", defaultJsonParser);\n\t\t\treturn WebSocketServiceInstance;\n\t\t}\n\n\t\t/**\n\t\t * Connect to a given endpoint for given socket-id.\n\t\t *\n\t\t * @param {string} url\t\t\t\t\t\t\t\tEndpoint to connect to.\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket id to connect for.\n\t\t */\n\t\tconnect(url, socketId=defaultSocketId) {\n\t\t\tif (!url && !ready) return afterReady.add(()=>connect(url, socketId));\n\t\t\tconnect(url, socketId);\n\t\t}\n\n\t\tdrop(socketId=defaultSocketId) {\n\t\t\tdrop(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for given message type on given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener callback.\n\t\t * @param {string} type\t\t\t\tMessage type to listen for.\n\t\t * @param {string} socketId\t\t\tSocket id to use.\n\t\t * @returns {Function}\t\t\t\tUnlisten function.\n\t\t */\n\t\tlisten(callback, type, socketId=defaultSocketId) {\n\t\t\tgetCallbacks(type, socketId).add(callback);\n\t\t\treturn ()=>getCallbacks(type, socketId).delete(callback);\n\t\t}\n\n\t\t/**\n\t\t * Remove a given listener on the given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener to remove.\n\t\t * @param {string} socketId\t\t\tSocket id to remove listener on.\n\t\t */\n\t\tremoveListener(callback, socketId) {\n\t\t\tif (socketId && callbacks.has(socketId)) return removeCallback(callbacks.get(socketId), callback);\n\t\t\tcallbacks.forEach(callbacks=>removeCallback(callbacks, callback));\n\t\t}\n\n\t\t/**\n\t\t * Send a request on the given socket.\n\t\t *\n\t\t * @param {Object} data\t\t\t\t\t\t\tData to send.\n\t\t * @param {string} [socketId=defaultSocketId]\tSocket to send on.\n\t\t * @param {string} [type=json]\t\t\t\t\tType of data to send.\n\t\t * @returns {Promise.<Object>}\t\t\t\t\tPromise resolving to server response.\n\t\t */\n\t\trequest(data, socketId=defaultSocketId, type='json') {\n\t\t\tdata.method = data.method || \"get\";\n\n\t\t\treturn new Promise((resolve, reject)=>{\n\t\t\t\tlet id = randomString();\n\t\t\t\tacknowledgements.set(id, createAcknowledge(resolve, reject));\n\t\t\t\tlet message = {type:\"request\", id, data};\n\t\t\t\tlet messageFunction = ()=>{\n\t\t\t\t\tif (parsers.has(type)) {\n\t\t\t\t\t\tconst _message = parsers.get(type)(message);\n\t\t\t\t\t\treturn _message;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new TypeError(`No parser for type ${type}`);\n\t\t\t\t};\n\t\t\t\tsend(messageFunction, socketId);\n\t\t\t});\n\t\t}\n\n\t\trequestJson(data, socketId=defaultSocketId) {\n\t\t\treturn this.request(data, socketId, 'json');\n\t\t}\n\n\t\t/**\n\t\t * Is given socket open and ready?\n\t\t *\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket to test for readiness.\n\t\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t\t */\n\t\tready(socketId=defaultSocketId) {\n\t\t\treturn !!socketReady(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add an endpoint url for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id set endpoint on.\n\t\t * @param {string} url\t\t\t\tThe endpoint url.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddEndpoint(id, url) {\n\t\t\tendpoints.set(id, url);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * remove an endpoint for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id to remove an endpoint for.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveEndpoint(id) {\n\t\t\tendpoints.delete(id);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Add a message parser for given type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to add for.\n\t\t * @param {Function} parser\t\t\tParser function to add.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddParser(type, parser) {\n\t\t\tparsers.set(type, parser);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Remove a parser for a given message type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to remove for.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveParser(type) {\n\t\t\tparsers.delete(type);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Get the default socket id.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget defaultSocketId() {\n\t\t\treturn defaultSocketId;\n\t\t}\n\n\t\t/**\n\t\t * Get the object type string.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget [Symbol.toStringTag]() {\n\t\t\treturn \"WebSocketService\";\n\t\t}\n\t}\n\n\tWebSocketService.DEBUG = false;\n\n\tinit();\n})(window);\n"]}