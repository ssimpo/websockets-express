{"version":3,"sources":["websockets-express.js"],"names":["global","$","WebSocketServiceInstance","buffer","ready","afterReady","Set","defaultSocketId","chars","split","endpoints","Map","callbacks","acknowledgements","sendQueue","sockets","parsers","status","SOCKETSTATUS","Object","freeze","CONNECTING","RECONNECTING","CLOSED","CONNECTED","init","document","addEventListener","onReady","websocket","WebSocketService","angular","module","factory","bolt","BoltWebSocketService","url","origin","location","baseElement","querySelector","base","getAttribute","trim","replace","set","setDefaultEndPoint","endpointLinkElements","querySelectorAll","length","n","title","setEndpoints","forEach","callback","clear","removeEventListener","notEnum","enumeral","checks","_status","check","randomString","arguments","undefined","Array","fill","map","end","start","Math","floor","random","randomInt","join","socketReady","socketId","has","ws","get","readyState","OPEN","getCallbacks","type","removeCallback","delete","connecting","open","console","log","concat","close","message","_sendQueue","messageFunction","send","runSendQueue","setTimeout","WebSocket","messageEvent","respond","id","acknowledgement","data","JSON","parse","Blob","reader","FileReader","onload","Buffer","Uint8Array","this","result","readAsArrayBuffer","err","error","connect","add","URIError","setEnpointUrl","defaultJsonParser","stringify","TypeError","_classCallCheck","addParser","_createClass","key","value","method","Promise","resolve","reject","response","errMessage","statusMessage","request","parser","Symbol","toStringTag","window","jQuery"],"mappings":"uYAAA,SAAAA,EAAAC,GACA,aAEA,IAwWAC,EAxWAC,EAAAH,EAAAG,OACAC,GAAA,EAEAC,EAAA,IAAAC,IACAC,EAAA,OACAC,EAAA,gEAAAC,MAAA,IACAC,EAAA,IAAAC,IACAC,EAAA,IAAAD,IACAE,EAAA,IAAAF,IACAG,EAAA,IAAAH,IACAI,EAAA,IAAAJ,IACAK,EAAA,IAAAL,IACAM,EAAA,IAAAN,IACAO,EAAAC,OAAAC,QACAC,WAAA,EACAC,aAAA,EACAC,OAAA,EACAC,UAAA,IAOA,SAAAC,IACAzB,EAAA0B,SAAAC,iBAAA,mBAAAC,GACA3B,IAAAA,EAAA4B,UAAA,IAAAC,GACA9B,EAAA+B,SAAA/B,EAAA+B,QAAAC,OAAA,wBAAAC,QAAA,aAAA,WAAA,OAAA,IAAAH,IAEA7B,GAAAD,EAAA+B,UACA/B,EAAAkC,KACAlC,EAAAkC,KAAAJ,iBAAAA,EAEA9B,EAAAmC,qBAAAL,GAQA,SAAAF,KAcA,YAmBA,WACA,IAEAQ,EAFAC,EAAArC,EAAAsC,SAAAD,OACAE,EAAAvC,EAAA0B,SAAAc,cAAA,cAEA,GAAAD,EAAA,CACA,IAAAE,GAAAF,EAAAG,aAAA,SAAA,IAAAC,OAAAC,QAAAP,EAAA,IACA,KAAAI,IAAAL,EAAAC,EAAAI,QAEAL,EAAAC,EAAA,IAGAD,EAAAA,EAAAQ,QAAA,WAAA,UAAAA,QAAA,UAAA,SAEAlC,EAAAmC,IAAAtC,EAAA6B,GA/BAU,GAEA,IAAAC,EAAA/C,EAAA0B,SAAAsB,iBAAA,sCACA,GAAAD,EAAAE,OACA,IAAA,IAAAC,EAAA,EAAAA,EAAAH,EAAAE,OAAAC,IAAA,CACA,IAAAd,GAAAW,EAAAG,GAAAR,aAAA,SAAA,IAAAC,OACA,GAAA,KAAAP,EAAA,CACA,IAAAe,GAAAJ,EAAAG,GAAAR,aAAA,UAAA,IAAAC,OACA,KAAAQ,IAAAA,EAAA5C,GACAG,EAAAmC,IAAAM,EAAAf,KAvBAgB,GACAhD,GAAA,EACAC,EAAAgD,QAAA,SAAAC,GAAA,OAAAA,MACAjD,EAAAkD,QACAvD,EAAA0B,SAAA8B,oBAAA,mBAAA/B,GAoDA,SAAAgC,EAAAxC,EAAAyC,EAAAC,GACA,IAAAC,GAAA,EAIA,OAHAD,EAAAN,QAAA,SAAAQ,GACAD,EAAAA,GAAA3C,IAAAyC,EAAAG,KAEAD,EAoBA,SAAAE,IAAA,IAAAb,EAAAc,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAA,GACA,OAAA,IAAAE,MAAAhB,GAAAiB,KAAA,GAAAC,IAAA,WAAA,OAAA3D,EAXA,SAAA4D,GAAA,IAAAC,EAAAN,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAA,EACA,OAAAO,KAAAC,MAAAD,KAAAE,SAAAJ,GAAAC,EAUAI,CAAAjE,EAAAyC,OAAA,MAAAyB,KAAA,IA4BA,SAAAC,IAAA,IAAAC,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EACA,GAAAQ,EAAA8D,IAAAD,GAAA,CACA,IAAAE,EAAA/D,EAAAgE,IAAAH,GACA,OAAAE,EAAAE,aAAAF,EAAAG,KAAAH,OAAAd,GAqCA,SAAAkB,EAAAC,GAAA,IAAAP,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EAGA,OAFAK,EAAAiE,IAAAD,IAAAhE,EAAAiC,IAAA+B,EAAA,IAAAjE,KACAC,EAAAmE,IAAAH,GAAAC,IAAAM,IAAAvE,EAAAmE,IAAAH,GAAA/B,IAAAsC,EAAA,IAAA7E,KACAM,EAAAmE,IAAAH,GAAAG,IAAAI,GASA,SAAAC,EAAAxE,EAAA0C,GACA1C,EAAAyC,QAAA,SAAAzC,GAAA,OAAAA,EAAAyE,OAAA/B,KAqDA,SAAAgC,EAAAR,EAAA1C,EAAAwC,GAIA,SAAAW,IACAtE,EAAA4B,IAAA+B,EAAA1D,EAAAM,WACAgE,QAAAC,IAAA,UAAAC,OAAAtD,EAAA,SAAAsD,OAAAd,IACAE,EAAAnD,iBAAA,QAAAgE,GACAb,EAAAnD,iBAAA,UAAAiE,GAvGA,WAAA,IAAAhB,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EACAsF,EAAA/E,EAAAiE,IAAAH,GACAE,EAAAH,EAAAC,GACAiB,GAAAf,IACAe,EAAAxC,QAAA,SAAAyC,GAAA,OAAAhB,EAAAiB,KAAAD,OACAD,EAAAtC,QACAzC,EAAAuE,OAAAT,IAkGAoB,CAAApB,GAMA,SAAAe,IAtCA,IAAAvD,EAAAwC,EAuCA3D,EAAA4B,IAAA+B,EAAA1D,EAAAK,QACAiE,QAAAC,IAAA,UAAAC,OAAAtD,EAAA,SAAAsD,OAAAd,IACAE,EAAAtB,oBAAA,OAAA+B,GACAT,EAAAtB,oBAAA,QAAAoC,GACAd,EAAAtB,oBAAA,UAAAoC,GA3CAxD,EA4CAA,EA5CAwC,EA4CAA,EA3CA7D,EAAAsE,OAAAT,GACAqB,WAAA,WACAxC,EAAAxC,EAAA8D,IAAAH,GAAA1D,GAAA,aAAA,eAAA,gBACAD,EAAA4B,IAAA+B,EAAA1D,EAAAI,cACAkE,QAAAC,IAAA,oBACA1E,EAAA8B,IAAA+B,EAAA,IAAAsB,UAAA9D,IACAkD,EAAAvE,EAAAgE,IAAAH,GAAAxC,EAAAwC,KAEA,KAqDA,SAAAgB,EAAAO,GACA,IAAAC,EAAA,SAAAR,GACA,GAAAA,EAAAS,IAKA,GAAAxF,EAAAgE,IAAAe,EAAAS,IAAA,CACA,IAAAC,EAAAzF,EAAAkE,IAAAa,EAAAS,IACA,UAAAT,EAAAT,KACAmB,EAAAV,EAAAW,KAAA,MAEAD,EAAA,KAAAV,EAAAW,MAEA1F,EAAAwE,OAAAO,EAAAS,UAXAzF,EAAAiE,IAAAe,EAAAT,OACAvE,EAAAmE,IAAAI,MAAA9B,QAAA,SAAAzC,GAAA,OAAA0C,SAAAsC,EAAAW,SAeA,GAAA,iBAAAJ,EAAAI,KACAH,EAAAI,KAAAC,MAAAN,EAAAI,YACA,GAAAJ,EAAAI,gBAAAG,KAAA,CACA,IAAAC,EAAA,IAAAC,WACAD,EAAAE,OAAA,WACAT,EAAA,IAAAjG,EAAA2G,OAAA,IAAAC,WAAAC,KAAAC,WAEAN,EAAAO,kBAAAf,EAAAI,OAIAzB,EAAAnD,iBAAA,QAxCA,SAAAwF,GAEA,OADA3B,QAAA4B,MAAA,YAAA1B,OAAAtD,EAAA,SAAAsD,OAAAd,GAAAuC,GACAxB,MAuCAb,EAAAnD,iBAAA,OAAA4D,GASA,SAAA8B,EAAAjF,EAAAwC,GACAxC,EA3HA,SAAAA,EAAAwC,GAQA,GAPAxC,IACAhC,EAGAM,EAAAmC,IAAA+B,EAAAxC,GAFA/B,EAAAiH,IAAA,WAAA,OAAA5G,EAAAmC,IAAA+B,EAAAxC,OAKAA,IAAA1B,EAAAmE,IAAAD,GAAA,MAAA,IAAA2C,SAAA,6BAAA7B,OAAAd,IAGA,OAFAxC,GAAA1B,EAAAmE,IAAAD,KAAAxC,EAAA1B,EAAAqE,IAAAH,IAEAxC,EAgHAoF,CAAApF,EAAAwC,GACAnB,EAAAxC,EAAA8D,IAAAH,GAAA1D,GAAA,aAAA,eAAA,gBACAD,EAAA4B,IAAA+B,EAAA1D,EAAAG,YACAN,EAAA8D,IAAAD,IAAA7D,EAAA8B,IAAA+B,EAAA,IAAAsB,UAAA9D,IACAkD,EAAAvE,EAAAgE,IAAAH,GAAAxC,EAAAwC,IAUA,SAAA6C,EAAAlB,GACA,IACA,OAAAC,KAAAkB,UAAAnB,GACA,MAAAY,GACA,MAAA,IAAAQ,UAAA,+CAvWA,IAkXA7F,EAlXA,WAmXA,SAAAA,IAGA,OAHA8F,gBAAAZ,KAAAlF,GACA5B,IAAAA,EAAA8G,MACAA,KAAAa,UAAA,OAAAJ,GACAvH,EAtXA,OAAA4H,aAAAhG,IAAAiG,IAAA,UAAAC,MAAA,SA+XA5F,GAAA,IAAAwC,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EACA,IAAA6B,IAAAhC,EAAA,OAAAC,EAAAiH,IAAA,WAAA,OAAAD,EAAAjF,EAAAwC,KACAyC,EAAAjF,EAAAwC,MAjYAmD,IAAA,OAAAC,MAAA,WAoYA,IA1IApD,EA0IAA,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EA1IAqE,EA2IAA,EA1IA7D,EAAAgE,IAAAH,GAAAe,WA3PAoC,IAAA,SAAAC,MAAA,SAgZA1E,EAAA6B,GAAA,IAAAP,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EAEA,OADA2E,EAAAC,EAAAP,GAAA0C,IAAAhE,GACA,WAAA,OAAA4B,EAAAC,EAAAP,GAAAS,OAAA/B,OAlZAyE,IAAA,iBAAAC,MAAA,SA2ZA1E,EAAAsB,GACA,GAAAA,GAAAhE,EAAAiE,IAAAD,GAAA,OAAAQ,EAAAxE,EAAAmE,IAAAH,GAAAtB,GACA1C,EAAAyC,QAAA,SAAAzC,GAAA,OAAAwE,EAAAxE,EAAA0C,QA7ZAyE,IAAA,UAAAC,MAAA,SAwaAzB,GAAA,IAAA3B,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EAAA4E,EAAApB,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAA,OAGA,OAFAwC,EAAA0B,OAAA1B,EAAA0B,QAAA,MAEA,IAAAC,QAAA,SAAAC,EAAAC,GACA,IAnSAD,EAAAC,EAmSA/B,EAAAvC,IACAjD,EAAAgC,IAAAwD,GApSA8B,EAoSAA,EApSAC,EAoSAA,EAnSA,SAAAjB,EAAAkB,GACA,GAAAlB,EAAA,OAAAiB,EAAAjB,GACA,IAAAkB,EAAApH,QAAA,MAAA,IAAA,CACA,GAAAkG,EAAA,OAAAiB,EAAAjB,GACA,IAAAmB,GAAAD,EAAAE,eAAA,IAAA5F,OACA,OAAAyF,EAAAE,GAEA,OAAAH,EAAAE,MA6RA,IAAAzC,GAAAT,KAAA,UAAAkB,GAAAA,EAAAE,KAAAA,IAxPA,SAAAT,GAAA,IAAAlB,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EACAuE,EAAAH,EAAAC,GACA,GAAAE,EAAA,OAAAA,EAAAiB,KAAAD,KACAhF,EAAA+D,IAAAD,IAAA9D,EAAA+B,IAAA+B,EAAA,IAAAtE,KACAQ,EAAAiE,IAAAH,GAAA0C,IAAAxB,GA4PAC,CAPA,WACA,GAAA/E,EAAA6D,IAAAM,GAEA,OADAnE,EAAA+D,IAAAI,EAAAnE,CAAA4E,GAGA,MAAA,IAAA+B,UAAA,sBAAAjC,OAAAP,KAEAP,QAtbAmD,IAAA,cAAAC,MAAA,SA0bAzB,GAAA,IAAA3B,EAAAb,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,EACA,OAAAyG,KAAAwB,QAAAjC,EAAA3B,EAAA,WA3bAmD,IAAA,QAAAC,MAAA,WAqcA,QAAArD,EADAZ,UAAAd,OAAA,QAAAe,IAAAD,UAAA,GAAAA,UAAA,GAAAxD,MApcAwH,IAAA,cAAAC,MAAA,SA+cA3B,EAAAjE,GAEA,OADA1B,EAAAmC,IAAAwD,EAAAjE,GACA4E,QAjdAe,IAAA,iBAAAC,MAAA,SA0dA3B,GAEA,OADA3F,EAAA2E,OAAAgB,GACAW,QA5dAe,IAAA,YAAAC,MAAA,SAseA7C,EAAAsD,GAEA,OADAzH,EAAA6B,IAAAsC,EAAAsD,GACAzB,QAxeAe,IAAA,eAAAC,MAAA,SAifA7C,GAEA,OADAnE,EAAAqE,OAAAF,GACA6B,QAnfAe,IAAA,kBAAAhD,IAAA,WA4fA,OAAAxE,KA5fAwH,IAogBAW,OAAAC,YApgBA5D,IAAA,WAqgBA,MAAA,uBArgBAjD,EAAA,GAygBAL,IAzgBA,CA0gBAmH,OAAAA,OAAAC","file":"websocket-express.min.js","sourcesContent":["(function(global, $){\n\t'use strict';\n\n\tlet buffer = global.buffer;\n\tlet ready = false;\n\n\tconst afterReady = new Set();\n\tconst defaultSocketId = 'main';\n\tconst chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('');\n\tconst endpoints = new Map();\n\tconst callbacks = new Map();\n\tconst acknowledgements = new Map();\n\tconst sendQueue = new Map();\n\tconst sockets = new Map();\n\tconst parsers = new Map();\n\tconst status = new Map();\n\tconst SOCKETSTATUS = Object.freeze({\n\t\tCONNECTING: 1,\n\t\tRECONNECTING: 2,\n\t\tCLOSED: 3,\n\t\tCONNECTED: 4\n\t});\n\n\n\t/**\n\t * Initiate this module, binding into all the correct global and framework points.\n\t */\n\tfunction init() {\n\t\tglobal.document.addEventListener(\"DOMContentLoaded\", onReady);\n\t\tif ($) $.websocket = new WebSocketService();\n\t\tif (global.angular) global.angular.module(\"websocket-express\", []).factory(\"$websocket\", ()=>new WebSocketService());\n\n\t\tif (!$ && !global.angular) {\n\t\t\tif (global.bolt) {\n\t\t\t\tglobal.bolt.WebSocketService = WebSocketService;\n\t\t\t} else {\n\t\t\t\tglobal.BoltWebSocketService = WebSocketService;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to call when document is ready.  Only run once to perform all waiting websocket messages.\n\t */\n\tfunction onReady() {\n\t\tsetEndpoints();\n\t\tready = true;\n\t\tafterReady.forEach(callback=>callback());\n\t\tafterReady.clear();\n\t\tglobal.document.removeEventListener(\"DOMContentLoaded\", init);\n\t}\n\n\n\t/**\n\t * Search through all the locations for websocket endpoint definitions setting these.  Will use defaults if non\n\t * found. These can be defined in <link rel=\"websocket-endpoint\"> tags, where the title attribute is the endpoint\n\t * name and the href is the endpoint.\n\t */\n\tfunction setEndpoints() {\n\t\tsetDefaultEndPoint();\n\n\t\tlet endpointLinkElements = global.document.querySelectorAll(\"link[rel=websocket-endpoint][href]\");\n\t\tif (endpointLinkElements.length) {\n\t\t\tfor (let n=0; n < endpointLinkElements.length; n++) {\n\t\t\t\tlet url = (endpointLinkElements[n].getAttribute(\"href\") || \"\").trim();\n\t\t\t\tif (url !== \"\") {\n\t\t\t\t\tlet title = (endpointLinkElements[n].getAttribute(\"title\") || \"\").trim();\n\t\t\t\t\tif (title === \"\") title = defaultSocketId;\n\t\t\t\t\tendpoints.set(title, url);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the endpoint of the default endpoint, searching all the definition points for this.\n\t */\n\tfunction setDefaultEndPoint() {\n\t\tlet origin = global.location.origin;\n\t\tlet baseElement = global.document.querySelector(\"base[href]\");\n\t\tlet url;\n\t\tif (baseElement) {\n\t\t\tlet base = (baseElement.getAttribute(\"href\") || \"\").trim().replace(origin, \"\");\n\t\t\tif (base !== \"\") url = origin+base;\n\t\t} else {\n\t\t\turl = origin+'/';\n\t\t}\n\n\t\turl = url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n\n\t\tendpoints.set(defaultSocketId, url);\n\t}\n\n\t/**\n\t * Check if a status property is not one of a number of enum values.\n\t *\n\t * @param {*} status\t\t\tStatus to check.\n\t * @param {Object} enumeral\t\tEnum to check within.\n\t * @param {Arrray} checks\t\tEnum values to check.\n\t * @returns {boolean}\t\t\tDoes it pass the test.\n\t */\n\tfunction notEnum(status, enumeral, checks) {\n\t\tlet _status = true;\n\t\tchecks.forEach(check=>{\n\t\t\t_status = _status && (status !== enumeral[check])\n\t\t});\n\t\treturn _status;\n\t}\n\n\t/**\n\t * Generate a random integer between a start end end value.\n\t *\n\t * @param {integer} end\t\t\t\tThe start of the range.\n\t * @param {integer} [start=0]\t\tThe end of the range.\n\t * @returns {integer}\t\t\t\tRandom generated number.\n\t */\n\tfunction randomInt(end, start=0) {\n\t\treturn Math.floor(Math.random() * end) + start;\n\t}\n\n\t/**\n\t * Generate a randomstring.\n\t *\n\t * @param {integer} [length=32]\t\tThe length of string to generate.\n\t * @returns {string}\t\t\t\tRandom generated string.\n\t */\n\tfunction randomString(length=32) {\n\t\treturn (new Array(length)).fill(0).map(()=>chars[randomInt(chars.length - 1)]).join('');\n\t}\n\n\t/**\n\t * Create an acknowledge handler.\n\t *\n\t * @param {Function} resolve\t\tPromise resolve handler.\n\t * @param {Function} reject\t\t\tPromise rejection handler.\n\t * @returns {Function}\t\t\t\tThe handler.\n\t */\n\tfunction createAcknowledge(resolve, reject) {\n\t\treturn (err, response)=>{\n\t\t\tif (err) return reject(err);\n\t\t\tif ((response.status || 200) >= 400) {\n\t\t\t\tif (err) return reject(err);\n\t\t\t\tlet errMessage = (response.statusMessage || \"\").trim();\n\t\t\t\treturn reject(errMessage);\n\t\t\t}\n\t\t\treturn resolve(response);\n\t\t};\n\t}\n\n\t/**\n\t * Is given websocket ready for transporting data?\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to test.\n\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t */\n\tfunction socketReady(socketId=defaultSocketId) {\n\t\tif (!sockets.has(socketId)) return undefined;\n\t\tconst ws = sockets.get(socketId);\n\t\treturn ((ws.readyState === ws.OPEN) ? ws : undefined);\n\t}\n\n\t/**\n\t * Send all the messages for a given socket that are in the queue.\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to send messages for.\n\t */\n\tfunction runSendQueue(socketId=defaultSocketId) {\n\t\tconst _sendQueue = sendQueue.get(socketId);\n\t\tconst ws = socketReady(socketId);\n\t\tif (_sendQueue && ws) {\n\t\t\t_sendQueue.forEach(messageFunction=>ws.send(messageFunction()));\n\t\t\t_sendQueue.clear();\n\t\t\tsendQueue.delete(socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Send a given message on a given socket.\n\t *\n\t * @param {Function} messageFunction\t\t\t\tMessage function to call to generate the message.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to send on.\n\t */\n\tfunction send(messageFunction, socketId=defaultSocketId) {\n\t\tconst ws = socketReady(socketId);\n\t\tif (ws) return ws.send(messageFunction());\n\t\tif (!sendQueue.has(socketId)) sendQueue.set(socketId, new Set());\n\t\tsendQueue.get(socketId).add(messageFunction);\n\t}\n\n\t/**\n\t * Get callbacksfor given listen type on given socket.\n\t * @param {string} type\t\t\t\t\t\t\t\tThe type to get for.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to get callbacks for.\n\t * @returns {Array.<Function>}\t\t\t\t\t\tArray of callbacks.\n\t */\n\tfunction getCallbacks(type, socketId=defaultSocketId) {\n\t\tif (!callbacks.has(socketId)) callbacks.set(socketId, new Map());\n\t\tif (!callbacks.get(socketId).has(type)) callbacks.get(socketId).set(type, new Set());\n\t\treturn callbacks.get(socketId).get(type);\n\t}\n\n\t/**\n\t * Remove the given callback from a callback set.\n\t *\n\t * @param {Set.<Set>} callbacks\t\tCallback to search through.\n\t * @param {Function} callback\t\tCallback to remove.\n\t */\n\tfunction removeCallback(callbacks, callback) {\n\t\tcallbacks.forEach(callbacks=>callbacks.delete(callback));\n\t}\n\n\t/**\n\t * Get the endpoint url for the given socket id.\n\t *\n\t * @param {string} [url]\t\t\tThe url to set endpoint to.\n\t * @param {string} socketId\t\t\tThe socket id to set endpoint on.\n\t * @returns {string}\t\t\t\tThe endpoint url for given socket id.\n\t */\n\tfunction setEnpointUrl(url, socketId) {\n\t\tif (url) {\n\t\t\tif (!ready) {\n\t\t\t\tafterReady.add(()=>endpoints.set(socketId, url));\n\t\t\t} else {\n\t\t\t\tendpoints.set(socketId, url);\n\t\t\t}\n\t\t}\n\t\tif (!url && !endpoints.has(socketId)) throw new URIError(`No websocket endpoint for ${socketId}`);\n\t\tif (!url && endpoints.has(socketId)) url = endpoints.get(socketId);\n\n\t\treturn url;\n\t}\n\n\t/**\n\t * Try reconnecting to given socket after it has dropped.\n\t *\n\t * @param {string} url\t\t\tThe endpoint url for websocket.\n\t * @param {string} socketId\t\tThe socket id.\n\t */\n\tfunction reconnect(url, socketId) {\n\t\tsockets.delete(socketId);\n\t\tsetTimeout(()=>{\n\t\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\t\tstatus.set(socketId, SOCKETSTATUS.RECONNECTING);\n\t\t\t\tconsole.log(\"Trying reconnect\");\n\t\t\t\tsockets.set(socketId, new WebSocket(url));\n\t\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t\t}\n\t\t}, 1000*3);\n\t}\n\n\tfunction drop(socketId) {\n\t\tsockets.get(socketId).close();\n\t}\n\n\t/**\n\t * Handle websocket connection, errors and reconnection.\n\t *\n\t * @param {WebSocket} ws\t\t\tThe websocket to handle.\n\t * @param {string} url\t\t\t\tThe endpoint to connect to.\n\t * @param {string} socketId\t\t\tThe socket id to set.\n\t */\n\tfunction connecting(ws, url, socketId) {\n\t\t/**\n\t\t * After open listener, setup message handling and send the message queue.\n\t\t */\n\t\tfunction open() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTED);\n\t\t\tconsole.log(`Opened ${url} for ${socketId}`);\n\t\t\tws.addEventListener(\"close\", close);\n\t\t\tws.addEventListener(\"message\", message);\n\t\t\trunSendQueue(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Close listener, try to reconnect.\n\t\t */\n\t\tfunction close() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CLOSED);\n\t\t\tconsole.log(`Closed ${url} for ${socketId}`);\n\t\t\tws.removeEventListener(\"open\", open);\n\t\t\tws.removeEventListener(\"close\", message);\n\t\t\tws.removeEventListener(\"message\", message);\n\t\t\treconnect(url, socketId, ws);\n\t\t}\n\n\t\t/**\n\t\t * Handle any websocket errors.\n\t\t *\n\t\t * @param {Error} err\t\tError message to handle.\n\t\t */\n\t\tfunction error(err) {\n\t\t\tconsole.error(`Error on ${url} for ${socketId}`, err);\n\t\t\treturn close();\n\t\t}\n\n\t\t/**\n\t\t * Handle a message event\n\t\t *\n\t\t * @param {Event} messageEvent\t\tThe message event to handle.\n\t\t */\n\t\tfunction message(messageEvent) {\n\t\t\tconst respond = (message)=>{\n\t\t\t\tif (!message.id) {\n\t\t\t\t\tif (callbacks.has(message.type)) {\n\t\t\t\t\t\tcallbacks.get(type).forEach(callbacks=>callback(message.data));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (acknowledgements.has(message.id)) {\n\t\t\t\t\t\tlet acknowledgement = acknowledgements.get(message.id);\n\t\t\t\t\t\tif (message.type === 'error') {\n\t\t\t\t\t\t\tacknowledgement(message.data, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tacknowledgement(null, message.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacknowledgements.delete(message.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof messageEvent.data === 'string') {\n\t\t\t\trespond(JSON.parse(messageEvent.data));\n\t\t\t} else if (messageEvent.data instanceof Blob) {\n\t\t\t\tlet reader = new FileReader();\n\t\t\t\treader.onload = function() {\n\t\t\t\t\trespond(new buffer.Buffer(new Uint8Array(this.result)));\n\t\t\t\t};\n\t\t\t\treader.readAsArrayBuffer(messageEvent.data);\n\t\t\t}\n\t\t}\n\n\t\tws.addEventListener(\"error\", error);\n\t\tws.addEventListener(\"open\", open);\n\t}\n\n\t/**\n\t * Connect to a given endpoint for socket id supplied.\n\t *\n\t * @param {string} [url]\tThe endpoint to connect to.\n\t * @param socketId\t\t\tThe socket id to connecct for.\n\t */\n\tfunction connect(url, socketId) {\n\t\turl = setEnpointUrl(url, socketId);\n\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTING);\n\t\t\tif (!sockets.has(socketId)) sockets.set(socketId, new WebSocket(url));\n\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Json parser (default one applied by default to all new socket channels).\n\t *\n\t * @param {*} data\t\tData to parse into JSON.\n\t * @returns {string}\tJSON from the data.\n\t */\n\tfunction defaultJsonParser(data) {\n\t\ttry {\n\t\t\treturn JSON.stringify(data);\n\t\t} catch(err) {\n\t\t\tthrow new TypeError(`Could not convert data to json for sending`);\n\t\t}\n\t}\n\n\tlet WebSocketServiceInstance;\n\n\t/**\n\t * Websocket handler service\n\t *\n\t * @singleton\n\t */\n\tclass WebSocketService {\n\t\tconstructor() {\n\t\t\tif (!WebSocketServiceInstance) WebSocketServiceInstance = this;\n\t\t\tthis.addParser(\"json\", defaultJsonParser);\n\t\t\treturn WebSocketServiceInstance;\n\t\t}\n\n\t\t/**\n\t\t * Connect to a given endpoint for given socket-id.\n\t\t *\n\t\t * @param {string} url\t\t\t\t\t\t\t\tEndpoint to connect to.\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket id to connect for.\n\t\t */\n\t\tconnect(url, socketId=defaultSocketId) {\n\t\t\tif (!url && !ready) return afterReady.add(()=>connect(url, socketId));\n\t\t\tconnect(url, socketId);\n\t\t}\n\n\t\tdrop(socketId=defaultSocketId) {\n\t\t\tdrop(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for given message type on given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener callback.\n\t\t * @param {string} type\t\t\t\tMessage type to listen for.\n\t\t * @param {string} socketId\t\t\tSocket id to use.\n\t\t * @returns {Function}\t\t\t\tUnlisten function.\n\t\t */\n\t\tlisten(callback, type, socketId=defaultSocketId) {\n\t\t\tgetCallbacks(type, socketId).add(callback);\n\t\t\treturn ()=>getCallbacks(type, socketId).delete(callback);\n\t\t}\n\n\t\t/**\n\t\t * Remove a given listener on the given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener to remove.\n\t\t * @param {string} socketId\t\t\tSocket id to remove listener on.\n\t\t */\n\t\tremoveListener(callback, socketId) {\n\t\t\tif (socketId && callbacks.has(socketId)) return removeCallback(callbacks.get(socketId), callback);\n\t\t\tcallbacks.forEach(callbacks=>removeCallback(callbacks, callback));\n\t\t}\n\n\t\t/**\n\t\t * Send a request on the given socket.\n\t\t *\n\t\t * @param {Object} data\t\t\t\t\t\t\tData to send.\n\t\t * @param {string} [socketId=defaultSocketId]\tSocket to send on.\n\t\t * @param {string} [type=json]\t\t\t\t\tType of data to send.\n\t\t * @returns {Promise.<Object>}\t\t\t\t\tPromise resolving to server response.\n\t\t */\n\t\trequest(data, socketId=defaultSocketId, type='json') {\n\t\t\tdata.method = data.method || \"get\";\n\n\t\t\treturn new Promise((resolve, reject)=>{\n\t\t\t\tlet id = randomString();\n\t\t\t\tacknowledgements.set(id, createAcknowledge(resolve, reject));\n\t\t\t\tlet message = {type:\"request\", id, data};\n\t\t\t\tlet messageFunction = ()=>{\n\t\t\t\t\tif (parsers.has(type)) {\n\t\t\t\t\t\tconst _message = parsers.get(type)(message);\n\t\t\t\t\t\treturn _message;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new TypeError(`No parser for type ${type}`);\n\t\t\t\t};\n\t\t\t\tsend(messageFunction, socketId);\n\t\t\t});\n\t\t}\n\n\t\trequestJson(data, socketId=defaultSocketId) {\n\t\t\treturn this.request(data, socketId, 'json');\n\t\t}\n\n\t\t/**\n\t\t * Is given socket open and ready?\n\t\t *\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket to test for readiness.\n\t\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t\t */\n\t\tready(socketId=defaultSocketId) {\n\t\t\treturn !!socketReady(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add an endpoint url for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id set endpoint on.\n\t\t * @param {string} url\t\t\t\tThe endpoint url.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddEndpoint(id, url) {\n\t\t\tendpoints.set(id, url);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * remove an endpoint for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id to remove an endpoint for.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveEndpoint(id) {\n\t\t\tendpoints.delete(id);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Add a message parser for given type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to add for.\n\t\t * @param {Function} parser\t\t\tParser function to add.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddParser(type, parser) {\n\t\t\tparsers.set(type, parser);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Remove a parser for a given message type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to remove for.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveParser(type) {\n\t\t\tparsers.delete(type);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Get the default socket id.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget defaultSocketId() {\n\t\t\treturn defaultSocketId;\n\t\t}\n\n\t\t/**\n\t\t * Get the object type string.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget [Symbol.toStringTag]() {\n\t\t\treturn \"WebSocketService\";\n\t\t}\n\t}\n\n\tinit();\n})(window, window.jQuery);\n"]}