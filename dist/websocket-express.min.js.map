{"version":3,"sources":["websockets-express.js"],"names":["global","$","WebSocketServiceInstance","buffer","ready","afterReady","Set","defaultSocketId","chars","split","endpoints","Map","callbacks","acknowledgements","sendQueue","sockets","parsers","status","SOCKETSTATUS","Object","freeze","CONNECTING","RECONNECTING","CLOSED","CONNECTED","HTTP_ERROR","_Error","message","_getPrototypeOf2","_this","_classCallCheck","this","_len","arguments","length","params","Array","_key","_possibleConstructorReturn","_getPrototypeOf","call","apply","concat","_inherits","_wrapNativeSuper","Error","init","document","addEventListener","onReady","websocket","WebSocketService","angular","module","factory","bolt","BoltWebSocketService","url","origin","location","baseElement","querySelector","base","getAttribute","trim","replace","set","setDefaultEndPoint","endpointLinkElements","querySelectorAll","n","title","setEndpoints","forEach","callback","clear","removeEventListener","notEnum","enumeral","checks","_status","check","randomString","undefined","fill","map","end","start","Math","floor","random","randomInt","join","socketReady","socketId","has","ws","get","readyState","OPEN","getCallbacks","type","removeCallback","delete","connecting","open","console","log","close","_sendQueue","messageFunction","send","runSendQueue","setTimeout","WebSocket","messageEvent","respond","id","acknowledgement","data","JSON","parse","Blob","reader","FileReader","onload","Buffer","Uint8Array","result","readAsArrayBuffer","err","error","connect","add","URIError","setEnpointUrl","defaultJsonParser","stringify","TypeError","addParser","_createClass","key","value","method","Promise","resolve","reject","response","body","statusMessage","request","parser","Symbol","toStringTag","window","jQuery"],"mappings":"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","file":"websocket-express.min.js","sourcesContent":["(function(global, $){\n\t'use strict';\n\n\tlet buffer = global.buffer;\n\tlet ready = false;\n\n\tconst afterReady = new Set();\n\tconst defaultSocketId = 'main';\n\tconst chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('');\n\tconst endpoints = new Map();\n\tconst callbacks = new Map();\n\tconst acknowledgements = new Map();\n\tconst sendQueue = new Map();\n\tconst sockets = new Map();\n\tconst parsers = new Map();\n\tconst status = new Map();\n\tconst SOCKETSTATUS = Object.freeze({\n\t\tCONNECTING: 1,\n\t\tRECONNECTING: 2,\n\t\tCLOSED: 3,\n\t\tCONNECTED: 4\n\t});\n\n\tclass HTTP_ERROR extends Error {\n\t\tconstructor(message, ...params) {\n\t\t\tsuper(message.message,...params);\n\t\t\tthis.status = message.status;\n\t\t}\n\t}\n\n\t/**\n\t * Initiate this module, binding into all the correct global and framework points.\n\t */\n\tfunction init() {\n\t\tglobal.document.addEventListener(\"DOMContentLoaded\", onReady);\n\t\tif ($) $.websocket = new WebSocketService();\n\t\tif (global.angular) global.angular.module(\"websocket-express\", []).factory(\"$websocket\", ()=>new WebSocketService());\n\n\t\tif (!$ && !global.angular) {\n\t\t\tif (global.bolt) {\n\t\t\t\tglobal.bolt.WebSocketService = WebSocketService;\n\t\t\t} else {\n\t\t\t\tglobal.BoltWebSocketService = WebSocketService;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to call when document is ready.  Only run once to perform all waiting websocket messages.\n\t */\n\tfunction onReady() {\n\t\tsetEndpoints();\n\t\tready = true;\n\t\tafterReady.forEach(callback=>callback());\n\t\tafterReady.clear();\n\t\tglobal.document.removeEventListener(\"DOMContentLoaded\", init);\n\t}\n\n\n\t/**\n\t * Search through all the locations for websocket endpoint definitions setting these.  Will use defaults if non\n\t * found. These can be defined in <link rel=\"websocket-endpoint\"> tags, where the title attribute is the endpoint\n\t * name and the href is the endpoint.\n\t */\n\tfunction setEndpoints() {\n\t\tsetDefaultEndPoint();\n\n\t\tlet endpointLinkElements = global.document.querySelectorAll(\"link[rel=websocket-endpoint][href]\");\n\t\tif (endpointLinkElements.length) {\n\t\t\tfor (let n=0; n < endpointLinkElements.length; n++) {\n\t\t\t\tlet url = (endpointLinkElements[n].getAttribute(\"href\") || \"\").trim();\n\t\t\t\tif (url !== \"\") {\n\t\t\t\t\tlet title = (endpointLinkElements[n].getAttribute(\"title\") || \"\").trim();\n\t\t\t\t\tif (title === \"\") title = defaultSocketId;\n\t\t\t\t\tendpoints.set(title, url);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the endpoint of the default endpoint, searching all the definition points for this.\n\t */\n\tfunction setDefaultEndPoint() {\n\t\tlet origin = global.location.origin;\n\t\tlet baseElement = global.document.querySelector(\"base[href]\");\n\t\tlet url;\n\t\tif (baseElement) {\n\t\t\tlet base = (baseElement.getAttribute(\"href\") || \"\").trim().replace(origin, \"\");\n\t\t\tif (base !== \"\") url = origin+base;\n\t\t} else {\n\t\t\turl = origin+'/';\n\t\t}\n\n\t\turl = url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n\n\t\tendpoints.set(defaultSocketId, url);\n\t}\n\n\t/**\n\t * Check if a status property is not one of a number of enum values.\n\t *\n\t * @param {*} status\t\t\tStatus to check.\n\t * @param {Object} enumeral\t\tEnum to check within.\n\t * @param {Arrray} checks\t\tEnum values to check.\n\t * @returns {boolean}\t\t\tDoes it pass the test.\n\t */\n\tfunction notEnum(status, enumeral, checks) {\n\t\tlet _status = true;\n\t\tchecks.forEach(check=>{\n\t\t\t_status = _status && (status !== enumeral[check])\n\t\t});\n\t\treturn _status;\n\t}\n\n\t/**\n\t * Generate a random integer between a start end end value.\n\t *\n\t * @param {integer} end\t\t\t\tThe start of the range.\n\t * @param {integer} [start=0]\t\tThe end of the range.\n\t * @returns {integer}\t\t\t\tRandom generated number.\n\t */\n\tfunction randomInt(end, start=0) {\n\t\treturn Math.floor(Math.random() * end) + start;\n\t}\n\n\t/**\n\t * Generate a randomstring.\n\t *\n\t * @param {integer} [length=32]\t\tThe length of string to generate.\n\t * @returns {string}\t\t\t\tRandom generated string.\n\t */\n\tfunction randomString(length=32) {\n\t\treturn (new Array(length)).fill(0).map(()=>chars[randomInt(chars.length - 1)]).join('');\n\t}\n\n\t/**\n\t * Create an acknowledge handler.\n\t *\n\t * @param {Function} resolve\t\tPromise resolve handler.\n\t * @param {Function} reject\t\t\tPromise rejection handler.\n\t * @returns {Function}\t\t\t\tThe handler.\n\t */\n\tfunction createAcknowledge(resolve, reject) {\n\t\treturn (err, response)=>{\n\t\t\tif (err) return reject(err);\n\t\t\tif ((response.status || 200) >= 400) {\n\t\t\t\tif (err) return reject(err);\n\t\t\t\tconst message = (response.body || response.statusMessage || \"\").trim();\n\t\t\t\tconst status = (response.status || 400);\n\t\t\t\treturn reject(new HTTP_ERROR({message, status}));\n\t\t\t}\n\t\t\treturn resolve(response);\n\t\t};\n\t}\n\n\t/**\n\t * Is given websocket ready for transporting data?\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to test.\n\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t */\n\tfunction socketReady(socketId=defaultSocketId) {\n\t\tif (!sockets.has(socketId)) return undefined;\n\t\tconst ws = sockets.get(socketId);\n\t\treturn ((ws.readyState === ws.OPEN) ? ws : undefined);\n\t}\n\n\t/**\n\t * Send all the messages for a given socket that are in the queue.\n\t *\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket id to send messages for.\n\t */\n\tfunction runSendQueue(socketId=defaultSocketId) {\n\t\tconst _sendQueue = sendQueue.get(socketId);\n\t\tconst ws = socketReady(socketId);\n\t\tif (_sendQueue && ws) {\n\t\t\t_sendQueue.forEach(messageFunction=>ws.send(messageFunction()));\n\t\t\t_sendQueue.clear();\n\t\t\tsendQueue.delete(socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Send a given message on a given socket.\n\t *\n\t * @param {Function} messageFunction\t\t\t\tMessage function to call to generate the message.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to send on.\n\t */\n\tfunction send(messageFunction, socketId=defaultSocketId) {\n\t\tconst ws = socketReady(socketId);\n\t\tif (ws) return ws.send(messageFunction());\n\t\tif (!sendQueue.has(socketId)) sendQueue.set(socketId, new Set());\n\t\tsendQueue.get(socketId).add(messageFunction);\n\t}\n\n\t/**\n\t * Get callbacksfor given listen type on given socket.\n\t * @param {string} type\t\t\t\t\t\t\t\tThe type to get for.\n\t * @param {string} [socketId=defaultSocketId]\t\tThe socket to get callbacks for.\n\t * @returns {Array.<Function>}\t\t\t\t\t\tArray of callbacks.\n\t */\n\tfunction getCallbacks(type, socketId=defaultSocketId) {\n\t\tif (!callbacks.has(socketId)) callbacks.set(socketId, new Map());\n\t\tif (!callbacks.get(socketId).has(type)) callbacks.get(socketId).set(type, new Set());\n\t\treturn callbacks.get(socketId).get(type);\n\t}\n\n\t/**\n\t * Remove the given callback from a callback set.\n\t *\n\t * @param {Set.<Set>} callbacks\t\tCallback to search through.\n\t * @param {Function} callback\t\tCallback to remove.\n\t */\n\tfunction removeCallback(callbacks, callback) {\n\t\tcallbacks.forEach(callbacks=>callbacks.delete(callback));\n\t}\n\n\t/**\n\t * Get the endpoint url for the given socket id.\n\t *\n\t * @param {string} [url]\t\t\tThe url to set endpoint to.\n\t * @param {string} socketId\t\t\tThe socket id to set endpoint on.\n\t * @returns {string}\t\t\t\tThe endpoint url for given socket id.\n\t */\n\tfunction setEnpointUrl(url, socketId) {\n\t\tif (url) {\n\t\t\tif (!ready) {\n\t\t\t\tafterReady.add(()=>endpoints.set(socketId, url));\n\t\t\t} else {\n\t\t\t\tendpoints.set(socketId, url);\n\t\t\t}\n\t\t}\n\t\tif (!url && !endpoints.has(socketId)) throw new URIError(`No websocket endpoint for ${socketId}`);\n\t\tif (!url && endpoints.has(socketId)) url = endpoints.get(socketId);\n\n\t\treturn url;\n\t}\n\n\t/**\n\t * Try reconnecting to given socket after it has dropped.\n\t *\n\t * @param {string} url\t\t\tThe endpoint url for websocket.\n\t * @param {string} socketId\t\tThe socket id.\n\t */\n\tfunction reconnect(url, socketId) {\n\t\tsockets.delete(socketId);\n\t\tsetTimeout(()=>{\n\t\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\t\tstatus.set(socketId, SOCKETSTATUS.RECONNECTING);\n\t\t\t\tconsole.log(\"Trying reconnect\");\n\t\t\t\tsockets.set(socketId, new WebSocket(url));\n\t\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t\t}\n\t\t}, 1000*3);\n\t}\n\n\tfunction drop(socketId) {\n\t\tsockets.get(socketId).close();\n\t}\n\n\t/**\n\t * Handle websocket connection, errors and reconnection.\n\t *\n\t * @param {WebSocket} ws\t\t\tThe websocket to handle.\n\t * @param {string} url\t\t\t\tThe endpoint to connect to.\n\t * @param {string} socketId\t\t\tThe socket id to set.\n\t */\n\tfunction connecting(ws, url, socketId) {\n\t\t/**\n\t\t * After open listener, setup message handling and send the message queue.\n\t\t */\n\t\tfunction open() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTED);\n\t\t\tconsole.log(`Opened ${url} for ${socketId}`);\n\t\t\tws.addEventListener(\"close\", close);\n\t\t\tws.addEventListener(\"message\", message);\n\t\t\trunSendQueue(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Close listener, try to reconnect.\n\t\t */\n\t\tfunction close() {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CLOSED);\n\t\t\tconsole.log(`Closed ${url} for ${socketId}`);\n\t\t\tws.removeEventListener(\"open\", open);\n\t\t\tws.removeEventListener(\"close\", message);\n\t\t\tws.removeEventListener(\"message\", message);\n\t\t\treconnect(url, socketId, ws);\n\t\t}\n\n\t\t/**\n\t\t * Handle any websocket errors.\n\t\t *\n\t\t * @param {Error} err\t\tError message to handle.\n\t\t */\n\t\tfunction error(err) {\n\t\t\tconsole.error(`Error on ${url} for ${socketId}`, err);\n\t\t\treturn close();\n\t\t}\n\n\t\t/**\n\t\t * Handle a message event\n\t\t *\n\t\t * @param {Event} messageEvent\t\tThe message event to handle.\n\t\t */\n\t\tfunction message(messageEvent) {\n\t\t\tconst respond = (message)=>{\n\t\t\t\tif (!message.id) {\n\t\t\t\t\tif (callbacks.has(message.type)) {\n\t\t\t\t\t\tcallbacks.get(type).forEach(callbacks=>callback(message.data));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (acknowledgements.has(message.id)) {\n\t\t\t\t\t\tlet acknowledgement = acknowledgements.get(message.id);\n\t\t\t\t\t\tif (message.type === 'error') {\n\t\t\t\t\t\t\tacknowledgement(message.data, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tacknowledgement(null, message.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacknowledgements.delete(message.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof messageEvent.data === 'string') {\n\t\t\t\trespond(JSON.parse(messageEvent.data));\n\t\t\t} else if (messageEvent.data instanceof Blob) {\n\t\t\t\tlet reader = new FileReader();\n\t\t\t\treader.onload = function() {\n\t\t\t\t\trespond(new buffer.Buffer(new Uint8Array(this.result)));\n\t\t\t\t};\n\t\t\t\treader.readAsArrayBuffer(messageEvent.data);\n\t\t\t}\n\t\t}\n\n\t\tws.addEventListener(\"error\", error);\n\t\tws.addEventListener(\"open\", open);\n\t}\n\n\t/**\n\t * Connect to a given endpoint for socket id supplied.\n\t *\n\t * @param {string} [url]\tThe endpoint to connect to.\n\t * @param socketId\t\t\tThe socket id to connecct for.\n\t */\n\tfunction connect(url, socketId) {\n\t\turl = setEnpointUrl(url, socketId);\n\t\tif (notEnum(status.get(socketId), SOCKETSTATUS, ['CONNECTING', 'RECONNECTING', 'CONNECTED'])) {\n\t\t\tstatus.set(socketId, SOCKETSTATUS.CONNECTING);\n\t\t\tif (!sockets.has(socketId)) sockets.set(socketId, new WebSocket(url));\n\t\t\tconnecting(sockets.get(socketId), url, socketId);\n\t\t}\n\t}\n\n\t/**\n\t * Json parser (default one applied by default to all new socket channels).\n\t *\n\t * @param {*} data\t\tData to parse into JSON.\n\t * @returns {string}\tJSON from the data.\n\t */\n\tfunction defaultJsonParser(data) {\n\t\ttry {\n\t\t\treturn JSON.stringify(data);\n\t\t} catch(err) {\n\t\t\tthrow new TypeError(`Could not convert data to json for sending`);\n\t\t}\n\t}\n\n\tlet WebSocketServiceInstance;\n\n\t/**\n\t * Websocket handler service\n\t *\n\t * @singleton\n\t */\n\tclass WebSocketService {\n\t\tconstructor() {\n\t\t\tif (!WebSocketServiceInstance) WebSocketServiceInstance = this;\n\t\t\tthis.addParser(\"json\", defaultJsonParser);\n\t\t\treturn WebSocketServiceInstance;\n\t\t}\n\n\t\t/**\n\t\t * Connect to a given endpoint for given socket-id.\n\t\t *\n\t\t * @param {string} url\t\t\t\t\t\t\t\tEndpoint to connect to.\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket id to connect for.\n\t\t */\n\t\tconnect(url, socketId=defaultSocketId) {\n\t\t\tif (!url && !ready) return afterReady.add(()=>connect(url, socketId));\n\t\t\tconnect(url, socketId);\n\t\t}\n\n\t\tdrop(socketId=defaultSocketId) {\n\t\t\tdrop(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for given message type on given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener callback.\n\t\t * @param {string} type\t\t\t\tMessage type to listen for.\n\t\t * @param {string} socketId\t\t\tSocket id to use.\n\t\t * @returns {Function}\t\t\t\tUnlisten function.\n\t\t */\n\t\tlisten(callback, type, socketId=defaultSocketId) {\n\t\t\tgetCallbacks(type, socketId).add(callback);\n\t\t\treturn ()=>getCallbacks(type, socketId).delete(callback);\n\t\t}\n\n\t\t/**\n\t\t * Remove a given listener on the given socket.\n\t\t *\n\t\t * @param {Function} callback\t\tListener to remove.\n\t\t * @param {string} socketId\t\t\tSocket id to remove listener on.\n\t\t */\n\t\tremoveListener(callback, socketId) {\n\t\t\tif (socketId && callbacks.has(socketId)) return removeCallback(callbacks.get(socketId), callback);\n\t\t\tcallbacks.forEach(callbacks=>removeCallback(callbacks, callback));\n\t\t}\n\n\t\t/**\n\t\t * Send a request on the given socket.\n\t\t *\n\t\t * @param {Object} data\t\t\t\t\t\t\tData to send.\n\t\t * @param {string} [socketId=defaultSocketId]\tSocket to send on.\n\t\t * @param {string} [type=json]\t\t\t\t\tType of data to send.\n\t\t * @returns {Promise.<Object>}\t\t\t\t\tPromise resolving to server response.\n\t\t */\n\t\trequest(data, socketId=defaultSocketId, type='json') {\n\t\t\tdata.method = data.method || \"get\";\n\n\t\t\treturn new Promise((resolve, reject)=>{\n\t\t\t\tlet id = randomString();\n\t\t\t\tacknowledgements.set(id, createAcknowledge(resolve, reject));\n\t\t\t\tlet message = {type:\"request\", id, data};\n\t\t\t\tlet messageFunction = ()=>{\n\t\t\t\t\tif (parsers.has(type)) {\n\t\t\t\t\t\tconst _message = parsers.get(type)(message);\n\t\t\t\t\t\treturn _message;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new TypeError(`No parser for type ${type}`);\n\t\t\t\t};\n\t\t\t\tsend(messageFunction, socketId);\n\t\t\t});\n\t\t}\n\n\t\trequestJson(data, socketId=defaultSocketId) {\n\t\t\treturn this.request(data, socketId, 'json');\n\t\t}\n\n\t\t/**\n\t\t * Is given socket open and ready?\n\t\t *\n\t\t * @param {string} [socketId=defaultSocketId]\t\tSocket to test for readiness.\n\t\t * @returns {boolean}\t\t\t\t\t\t\t\tIs it ready?\n\t\t */\n\t\tready(socketId=defaultSocketId) {\n\t\t\treturn !!socketReady(socketId);\n\t\t}\n\n\t\t/**\n\t\t * Add an endpoint url for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id set endpoint on.\n\t\t * @param {string} url\t\t\t\tThe endpoint url.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddEndpoint(id, url) {\n\t\t\tendpoints.set(id, url);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * remove an endpoint for a given id.\n\t\t *\n\t\t * @param {string} id\t\t\t\tThe id to remove an endpoint for.\n\t\t * @param {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveEndpoint(id) {\n\t\t\tendpoints.delete(id);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Add a message parser for given type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to add for.\n\t\t * @param {Function} parser\t\t\tParser function to add.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\taddParser(type, parser) {\n\t\t\tparsers.set(type, parser);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Remove a parser for a given message type.\n\t\t *\n\t\t * @param {string} type\t\t\t\tMessage type to remove for.\n\t\t * @returns {WebSocketService}\t\tFor chaining.\n\t\t */\n\t\tremoveParser(type) {\n\t\t\tparsers.delete(type);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Get the default socket id.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget defaultSocketId() {\n\t\t\treturn defaultSocketId;\n\t\t}\n\n\t\t/**\n\t\t * Get the object type string.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tget [Symbol.toStringTag]() {\n\t\t\treturn \"WebSocketService\";\n\t\t}\n\t}\n\n\tinit();\n})(window, window.jQuery);\n"]}